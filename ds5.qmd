---
title: "EDA"
format: html
editor: visual
---

## Libraries

Before getting started lets read in the necessary libraries

```{r}
library("tidyverse")
```

## Task 1: Read in & Modify

Lets read in our data. The below code chunked was pulled from the `student-merge.R` file in our `files` folder and modified to reflect the folder structure of this project.

```{r}
d1=read.table("files/student-mat.csv",sep=";",header=TRUE)
d2=read.table("files/student-por.csv",sep=";",header=TRUE)

d3=merge(d1,d2,by=c("school","sex","age","address","famsize","Pstatus","Medu","Fedu","Mjob","Fjob","reason","nursery","internet"))
d3
```

For the purpose of this homework, we want to read the data in the tidyverse way. We will use the joins provided the the source team.

One thing we notice is that there are other columns outside of those in the specified join that seem to match, which could result in duplication and highly dimensional data. Some examples include *guardian, freetime, and famrel*. In addition, some variables that appear to be cateogrical and should be cast as factors are cast as **dbl** type.

```{r}
math_data <- read_delim(file="files/student-mat.csv",delim=";",show_col_types = FALSE)
port_data <- read_delim(file="files/student-por.csv",delim=";",show_col_types = FALSE)
merged_data <- inner_join(math_data,port_data,by=c("school","sex","age","address","famsize","Pstatus","Medu","Fedu","Mjob","Fjob","reason","nursery","internet"))

merged_data
```

Lets instead merge our data on all columns besides `G1`, `G2`, `G3`, `paid`, and `absences`. We know in our `colnames` output those NOT joined will have *.x* or *.y* following them, so we can confirm the appropriate columns were not included.

We also see that our tibble maintains the same \# of observations

```{r}
joinCols <- colnames(math_data)[!(colnames(math_data) %in% c('G1','G2','G3','paid','absences'))]
merged_data <- inner_join(math_data,port_data,by=joinCols)
colnames(merged_data)
merged_data
```

Now to pick 4 variables that we can cast as factors across our 4 data frames. I think that address, studytime, famsup and activities will be interesting to look at.

To avoid repetitive code, we will write a function that takes in a vector of column names and applies to the tibbles. We'll apply that function across tibbles

```{r}
TibbleMultiFactor <- function (tibble,variables=NULL){
  returnTibble <- tibble %>%
      mutate(across(all_of(variables), as.factor))
  return(returnTibble)
}

variablesToFactor <- c('address','studytime','famsup','activities')

math_data <- TibbleMultiFactor(math_data,variables=variablesToFactor)
port_data <- TibbleMultiFactor(port_data,variables=variablesToFactor)
merged_data <- TibbleMultiFactor(merged_data,variables=variablesToFactor)
```

## Task 2: Part A - Categorical Variables

We will create one-way, two-way and three-way contingency tables based on our factor variables from a previous code block.

Explaining a result from each table

1.  157 students were in studytime category "2" (One-Way)
2.  105 students who were in studytime category "2" had family support (Two-Way)
3.  55 students who were in the studytime category "2" had family support but did NOT participate in extracurricular activities (Three-Way)

```{r}
one_way <- table(merged_data$studytime)
paste0("This is the one-way table output")
one_way

two_way <- table(merged_data$studytime, merged_data$famsup)
paste0("This is the two-way table output")
two_way

three_way <- table(merged_data$studytime, merged_data$famsup, merged_data$activities)
paste0("This is the three-way table output")
three_way
```
We can subset our data many ways to get similar results. In the `twoWayFilter` object we are using data subsetted on *famsup* = *yes* and then creating our conditional contingency table.

Likewise, we are taking our `three-way` contingency table and subsetting on *famsup*=*yes*. You can see both outputs yield the same results.

```{r}
filterData <- merged_data %>%
  filter(famsup == "yes")

twoWayFilter <- table(filterData$studytime,filterData$activities)
twoWayFilter

twoWayFromThree <- three_way[,"yes",]
twoWayFromThree
```

We can also create two way tables using `dplyr` package. You'll see we get the same datapoints (different format) as `two_way` object which was created using table().

```{r}
twoWayDplyr <- merged_data %>%
  group_by(studytime, famsup) %>%
  drop_na(studytime, famsup) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = famsup, values_from = count)

twoWayDplyr
```

Lets create some visualizations to represent the output above. We are making a stacked bar chart and a side-by-side bar chart.

```{r}
catBasePlot <- ggplot(data = merged_data %>% drop_na(studytime, famsup), aes(x = studytime, fill = famsup))

catStackBar <- catBasePlot +
  geom_bar() +
  labs(x = "Study Time", y = "# Students", title = "Number of Students by Study Time Level")

catSideBySide <- catBasePlot +
  geom_bar(position = 'dodge') +
  labs(x = "Study Time", y = "# Students", title = "Number of Students by Study Time Level") +
  scale_fill_discrete("Family Support")

catStackBar
catSideBySide
  
```

## Task 2: Numeric Variables

To practice with 

```{r}
ageOnly <- merged_data %>%
  drop_na(age) %>%
  summarize("mean" = mean(age),
            "median" = median(age),
            "var" = var(age),
            "sd" = sd(age),
            "IQR" = IQR(age)
            )

mathAbsOnly <- merged_data %>%
  drop_na(absences.x) %>%
  summarize("mean" = mean(absences.x),
            "median" = median(absences.x),
            "var" = var(absences.x),
            "sd" = sd(absences.x),
            "IQR" = IQR(absences.x)
            )

mathG3Only <- merged_data %>%
  drop_na(G3.x) %>%
  summarize("mean" = mean(G3.x),
            "median" = median(G3.x),
            "var" = var(G3.x),
            "sd" = sd(G3.x),
            "IQR" = IQR(G3.x)
            )

paste0("Below are measures of center and spread for age")
ageOnly
paste0("Below are measures of center and spread for math absences")
mathAbsOnly
paste0("Below are measures of center and spread for math final grades")
mathG3Only


```
Lets fetch our measures of center and spread across math absences, math first test grade and math final grade when grouping by age

```{r}
ageGroupMetrics <- merged_data %>%
  select(age,absences.x,G1.x,G3.x) %>%
  group_by(age) %>%
  drop_na(age,absences.x,G1.x,G3.x) %>%
  summarize(across(everything(), .fns = list("mean" = mean,
                                       "median" = median,
                                       "var" = var,
                                       "sd" = sd,
                                       "IQR" = IQR), .names = "{.fn}_{.col}"))

ageGroupMetrics
```

Lets fetch our measures of center and spread across math first test grade, math second test grade and math final grade when grouping by age and absences

```{r}
ageAbsGroupMetrics <- merged_data %>%
  select(age,absences.x,G1.x,G2.x,G3.x) %>%
  group_by(age,absences.x) %>%
  drop_na(age,absences.x,G1.x,G2.x,G3.x) %>%
  summarize(across(everything(), .fns = list("mean" = mean,
                                       "median" = median,
                                       "var" = var,
                                       "sd" = sd,
                                       "IQR" = IQR), .names = "{.fn}_{.col}"))

ageAbsGroupMetrics
```

Of all our numeric variables, we want to see a correlation matrix for everything. Lets do this by subsetting our data and using the `cor()` function

```{r}
corrMatrix <- merged_data %>%
  select(age,absences.x,G1.x,G2.x,G3.x,absences.y,G1.y,G2.y,G3.y) %>%
  cor()

corrMatrix
```

